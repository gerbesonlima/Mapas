<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Relatório de Mapas Trabalhados</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <style>
    /* Tipografia Global - Priorizando Roboto, a fonte padrão do Android */
    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      background-color: #FAFAFA; /* Fundo padrão Material Design (cinza bem claro) */
      color: #212121; /* Cor de texto primária Material (quase preto) */
      line-height: 1.6;
      padding-bottom: 60px;
    }

    /* AppBar (Cabeçalho Principal) */
    h1 {
      background-color: #4CAF50; /* Verde primário */
      color: #FFFFFF;
      padding: 16px 24px; /* Espaçamento Material (16dp nas laterais, altura comum de 56dp) */
      margin: 0;
      font-size: 1.25rem; /* Equivalente a 20sp no Material */
      font-weight: 500; /* Medium weight */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      text-align: left;
      line-height: 1.4; /* Para altura de 56px com padding */
    }

    /* Títulos de Seção */
    h2 {
      text-align: center;
      color: #4CAF50; /* Cor primária */
      font-size: 1.5rem; /* Um pouco maior */
      font-weight: 400; /* Normal weight */
      margin-top: 32px;
      margin-bottom: 16px;
    }

    h3 {
      text-align: center;
      color: #757575; /* Cor de texto secundária */
      font-size: 1.1rem;
      font-weight: 500;
      margin-top: 24px;
      margin-bottom: 8px;
    }

    /* Contêineres de Conteúdo e Controles */
    .content-wrapper, .controls-wrapper {
      padding: 0 16px; /* Espaçamento lateral */
      max-width: 900px;
      margin: 0 auto 24px auto;
      text-align: center;
    }

    /* Informação do Ciclo Atual - Estilo de Chip/Card Pequeno */
    #current-cycle-info {
      font-weight: 500;
      margin: 16px 0;
      padding: 12px 16px;
      background-color: #EEEEEE; /* Cinza claro Material */
      border-radius: 18px; /* Mais arredondado, como um chip grande */
      display: inline-block;
      min-height: auto;
      vertical-align: middle;
      color: #212121;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    #current-cycle-info span {
        display: block;
        line-height: 1.4;
    }
    #current-cycle-display {
        font-size: 0.9rem;
    }


   .progress-container {
      width: 100%;
      max-width: 900px;
      margin: 16px auto 24px auto;
      background-color: #E0E0E0; 
      border-radius: 4px; /* Raio um pouco maior para uma barra mais alta */
      overflow: hidden;
      height: 24px; /* Altura aumentada para acomodar texto */
      box-shadow: none;
    }
    .progress-bar {
      height: 24px; /* Mesma altura do contêiner */
      background-color: #4CAF50; 
      text-align: center; /* Centraliza o texto na barra */
      color: white;
      line-height: 24px; /* Centraliza verticalmente o texto */
      width: 0%;
      transition: width 0.4s ease;
      font-weight: 500; /* Peso de fonte Material Medium */
      border-radius: 4px; /* Raio consistente */
      font-size: 0.8rem; /* Tamanho de fonte legível para o texto */
      white-space: nowrap; /* Evita que o texto quebre em múltiplas linhas */
      overflow: hidden; /* Evita que o texto saia da barra */
      padding: 0 8px; /* Adiciona um pequeno padding lateral para o texto não colar nas bordas */
      box-sizing: border-box; /* Inclui padding na largura total */
    }
    .progress-bar[style*="width: 100%"] { /* Garante borda arredondada completa em 100% */
        border-radius: 4px;
    }


    /* Botões - Estilo Material Design */
    button {
      background-color: #4CAF50; /* Cor primária */
      color: #FFFFFF;
      border: none;
      padding: 0 16px; /* Padding horizontal Material */
      height: 36px; /* Altura padrão Material */
      line-height: 36px; /* Para centralizar o texto */
      cursor: pointer;
      border-radius: 4px; /* Raio de borda Material */
      font-weight: 500; /* Medium weight */
      text-transform: uppercase;
      font-size: 0.875rem; /* 14sp */
      box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 
                  0 3px 1px -2px rgba(0,0,0,0.12), 
                  0 1px 5px 0 rgba(0,0,0,0.2); /* Sombra padrão de botão elevado */
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1), 
                  background-color 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      margin: 8px 4px; /* Espaçamento entre botões */
      outline: none;
    }
    button:hover:not(:disabled) {
      background-color: #43A047; /* Levemente mais escuro no hover */
      box-shadow: 0 3px 3px 0 rgba(0,0,0,0.14), 
                  0 1px 7px 0 rgba(0,0,0,0.12), 
                  0 3px 1px -1px rgba(0,0,0,0.2);
    }
    button:active:not(:disabled) { /* Feedback de pressionado */
        background-color: #388E3C;
        box-shadow: 0 4px 5px -2px rgba(0,0,0,0.14),
                    0 2px 10px 0px rgba(0,0,0,0.12),
                    0 1px 8px 1px rgba(0,0,0,0.20);
    }
    button:disabled {
        background-color: rgba(0,0,0,0.12);
        color: rgba(0,0,0,0.26);
        box-shadow: none;
        cursor: not-allowed;
    }

    /* Variações de Botões */
    button.secondary-action {
        background-color: #2196F3; /* Azul Material para ações secundárias */
    }
    button.secondary-action:hover:not(:disabled) {
        background-color: #1E88E5;
    }
    button.secondary-action:active:not(:disabled) {
        background-color: #1976D2;
    }

    button.warning-action { /* Para ações que requerem atenção, como "Desfazer" ou "Salvar Edição" */
        background-color: #FF9800; /* Laranja Material */
        color: #FFFFFF;
    }
    button.warning-action:hover:not(:disabled) {
        background-color: #FB8C00;
    }
     button.warning-action:active:not(:disabled) {
        background-color: #F57C00;
    }

    button.danger-action {
        background-color: #F44336; /* Vermelho Material para perigo */
    }
    button.danger-action:hover:not(:disabled) {
        background-color: #E53935;
    }
    button.danger-action:active:not(:disabled) {
        background-color: #D32F2F;
    }
    
    /* Inputs e Select - Estilo Material (simplificado com CSS puro) */
    input[type="text"], input[type="date"], select {
      padding: 10px 0px 8px 0px; /* Padding focado na parte inferior */
      border: none;
      border-bottom: 1px solid rgba(0,0,0,0.12); /* Linha inferior sutil */
      border-radius: 0; /* Sem bordas arredondadas para inputs de linha */
      box-sizing: border-box;
      width: 100%;
      margin: 8px 0 16px 0; /* Espaçamento */
      background-color: transparent; /* Fundo transparente */
      font-size: 1rem; /* 16sp */
      transition: border-bottom-color 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      outline: none;
    }
    input[type="text"]:focus, input[type="date"]:focus, select:focus {
      border-bottom: 2px solid #4CAF50; /* Cor primária na linha inferior ao focar */
      margin-bottom: 15px; /* Ajuste para a borda mais grossa */
    }
    /* Placeholder com cor Material */
    input[type="text"]::placeholder {
        color: rgba(0,0,0,0.38);
        opacity: 1; /* Firefox */
    }

    select {
        width: auto;
        min-width: 200px;
        margin-right: 10px;
        padding: 10px 8px 8px 2px; /* Ajuste para select */
        appearance: none; /* Remove aparência padrão do SO */
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 8px top 50%;
        background-size: .65em auto;
        padding-right: 2em; /* Espaço para a seta */
    }

    /* Tabelas com estilo de Card Material */
    table {
      width: 100%;
      max-width: 900px;
      margin: 24px auto;
      border-collapse: collapse;
      background-color: #FFFFFF; /* Fundo branco para o card */
      border-radius: 4px; /* Raio Material */
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); /* Sombra de card */
      overflow: hidden; /* Para o raio de borda funcionar com as células */
    }
    th, td {
      padding: 16px; /* Padding Material para células de tabela */
      text-align: left;
      border: none; /* Remove bordas individuais das células */
      color: #212121; /* Cor de texto primária */
    }
    th {
      background-color: #FFFFFF; /* Cabeçalho da tabela sem fundo forte */
      color: #757575; /* Cor de texto secundária para cabeçalhos */
      font-weight: 500; /* Medium weight */
      border-bottom: 1px solid rgba(0,0,0,0.12); /* Separador Material */
      font-size: 0.875rem; /* 14sp */
    }
    td {
      border-bottom: 1px solid rgba(0,0,0,0.12); /* Separador Material entre linhas */
       font-size: 0.875rem; /* 14sp */
       line-height: 1.4;
    }
    tr:last-child td {
      border-bottom: none; /* Remove borda da última linha */
    }
    tr:hover { /* Feedback sutil no hover para web */
      background-color: rgba(0,0,0,0.03); 
    }

    /* Ajustes para inputs dentro de células de tabela quando em modo de edição */
    td input[type="text"], td input[type="date"]{
        padding: 8px 0px; /* Padding menor para inputs em tabela */
        font-size: 0.875rem; /* Mesmo tamanho da célula */
        margin: 0; /* Remove margens extras dentro da célula */
        line-height: normal;
    }
    td input[type="text"]:focus, td input[type="date"]:focus {
      margin-bottom: -1px; /* Compensar a borda de foco de 2px */
    }

    /* Área de seleção de ciclo */
    #cycle-selection-area {
        margin-top: 16px;
        padding: 16px;
        background-color: #FFFFFF;
        border-radius: 4px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    #cycle-selection-area label {
        color: #757575;
        font-size: 0.875rem;
        margin-right: 8px;
    }
    #cycle-selection-area button {
        margin-top: 10px;
    }
    #historico-edit-controls button {
        margin-bottom: 16px; /* Espaço abaixo do botão de edição geral */
    }

    @media (max-width: 767px) { /* Ajuste este valor conforme necessário para o seu "ponto de quebra" móvel */
    #historico-table th:nth-child(5), /* Ciclo (Nº) */
    #historico-table td:nth-child(5),
    #historico-table th:nth-child(6), /* Ações */
    #historico-table td:nth-child(6) {
        /* Se quiser esconder a coluna de Ações também em telas menores, descomente as duas linhas abaixo */
        /* display: none; */ 
    }
     /* Ajusta o tamanho do botão de arquivar para caber melhor */
    #historico-table button.archive-btn {
        font-size: 0.75rem; /* Tamanho de fonte menor */
        padding: 0 8px; /* Padding horizontal menor */
        height: 30px; /* Altura menor */
        line-height: 30px; /* Linha-altura correspondente */
    }

}

</style>
</head>
<body>
  <h1>Relatório de Mapas Trabalhados</h1>

  <div class="controls-wrapper">
    <h3>Gerenciamento de Ciclos</h3>
    <div id="current-cycle-info">
      Ciclo Atual: <span id="current-cycle-display">Carregando...</span>
    </div>
    <div id="cycle-actions">
      <button onclick="startNewCyclePrompt()" class="secondary-action">Começar Novo Ciclo</button>
      <button id="pause-cycle-btn" onclick="pauseActiveCycle()" style="display:none;">Pausar Ciclo Atual</button>
      <button id="continue-cycle-btn" onclick="continueCyclePrompt()" style="display:none;">Continuar Ciclo</button>
      <button id="exclude-cycle-btn" onclick="excludeCyclePrompt()" class="danger-action">Excluir Ciclo</button>
    </div>
    
    <div id="cycle-selection-area" style="margin-top: 10px;"></div>
     <div class="progress-container">
      <div class="progress-bar" id="progress-bar">0%</div>
    </div>
  </div>

  <div class="content-wrapper">
    <h2>Mapas em Andamento</h2>
    <table id="relatorio-table">
      <thead>
        <tr>
          <th>Nº do Mapa</th>
          <th>Designado para</th>
          <th>Data de Início</th>
          <th>Data de Fim</th>
          <th>Ação</th>
        </tr>
      </thead>
      <tbody id="relatorio-body"></tbody>
    </table>

    <h2>Histórico de Mapas Concluídos</h2>
    <div id="historico-edit-controls" style="text-align:center; margin-bottom:10px;">
        <button id="toggle-historico-edit-btn" onclick="toggleGlobalHistoricoEdit()">Habilitar Edição Geral</button>
    </div>
    <table id="historico-table">
      <thead>
        <tr>
          <th>Nº do Mapa</th>
          <th>Designado para</th>
          <th>Data de Início</th>
          <th>Data de Fim</th>
          <th>Ciclo (Nº)</th>
          <th>Ações</th> 
        </tr>
      </thead>
      <tbody id="historico-body"></tbody>
    </table>
  </div>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyD75RGb3lOiZ0azcSjtP_b9VcZPlHCelJY", // Substitua pela sua configuração real
      authDomain: "territorios-3d0bb.firebaseapp.com",
      projectId: "territorios-3d0bb",
      storageBucket: "territorios-3d0bb.appspot.com", // Verifique se é appspot.com ou firebasestorage.app para seu projeto
      messagingSenderId: "712377474662",
      appId: "1:712377474662:web:dfb86ef024b18aa2cb97a7",
      measurementId: "G-DME60YZGXX",
      databaseURL: "https://territorios-3d0bb-default-rtdb.firebaseio.com"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let activeCycleData = null; 
    let isHistoricoEditingGlobal = false;
    let allCyclesMap = {}; 

    function formatarData(data) {
      if (!data || String(data).trim() === "") return "—"; 
      const parts = String(data).split("-");
      if (parts.length === 3) {
        const [ano, mes, dia] = parts;
        if (ano && mes && dia && !isNaN(parseInt(dia)) && !isNaN(parseInt(mes)) && !isNaN(parseInt(ano))) {
             return `${String(dia).padStart(2,'0')}/${String(mes).padStart(2,'0')}/${ano}`;
        }
      }
      return "—"; 
    }
    
    function getTodayDateString() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    async function loadActiveCycleDetails() {
        console.log("Iniciando loadActiveCycleDetails...");
        let activeCycleId = null;
        activeCycleData = null; 

        const activeCycleIdSnap = await db.ref("cicloAtualId").once("value");
        activeCycleId = activeCycleIdSnap.val();

        if (activeCycleId) {
            console.log(`Encontrado cicloAtualId: ${activeCycleId}`);
        } else {
            console.log("Nenhum cicloAtualId encontrado. Verificando 'cicloAtual' legado...");
            const legacyCicloAtualSnap = await db.ref("cicloAtual").once("value");
            const legacyCicloKey = legacyCicloAtualSnap.val();
            if (legacyCicloKey && typeof legacyCicloKey === 'string') {
                console.log("Legacy 'cicloAtual' encontrado:", legacyCicloKey);
                const legacyCycleSnap = await db.ref(`ciclos/${legacyCicloKey}`).once("value");
                if (legacyCycleSnap.exists()) {
                    activeCycleId = legacyCicloKey;
                    console.log(`Ciclo legado '${legacyCicloKey}' existe. Migrando para 'cicloAtualId'.`);
                    await db.ref('cicloAtualId').set(legacyCicloKey);
                    await db.ref('cicloAtual').remove(); 
                    console.log(`Migrado para 'cicloAtualId': ${legacyCicloKey}`);
                } else {
                     console.log(`Ciclo legado '${legacyCicloKey}' não encontrado em /ciclos.`);
                }
            }
        }

        if (activeCycleId) {
            const cycleSnap = await db.ref(`ciclos/${activeCycleId}`).once("value");
            if (cycleSnap.exists()) {
                let cycleData = cycleSnap.val();
                let needsUpdateInDB = false; 

                if (typeof cycleData.numero === 'undefined') {
                    cycleData.numero = 1; 
                    needsUpdateInDB = true;
                }
                if (typeof cycleData.nome === 'undefined' || String(cycleData.nome).trim() === '') {
                    cycleData.nome = (activeCycleId === 'ciclo_1' && cycleData.numero === 1) ? "Ciclo 1 (Importado)" : `Ciclo ${cycleData.numero}`;
                    needsUpdateInDB = true;
                }
                if (typeof cycleData.status === 'undefined') {
                    cycleData.status = 'ativo'; 
                    needsUpdateInDB = true;
                }
                if (typeof cycleData.dataInicio === 'undefined') {
                    cycleData.dataInicio = "2023-01-01"; 
                    needsUpdateInDB = true;
                }

                if (needsUpdateInDB) {
                    console.log(`Atualizando dados do ciclo '${activeCycleId}' no Firebase com padrões.`);
                    await db.ref(`ciclos/${activeCycleId}`).update({
                        nome: cycleData.nome,
                        numero: cycleData.numero,
                        status: cycleData.status,
                        dataInicio: cycleData.dataInicio
                    });
                }
                activeCycleData = { id: activeCycleId, ...cycleData };
                console.log("Ciclo ativo carregado:", activeCycleData);

                if (activeCycleId === 'ciclo_1' && activeCycleData.numero === 1) {
                    console.log("Verificando migração para historicoMapas com 'ciclo_1'...");
                    const historicoRef = db.ref('historicoMapas');
                    const snapshot = await historicoRef.orderByChild('ciclo').equalTo('ciclo_1').once('value');
                    if (snapshot.exists()) {
                        const updates = {};
                        snapshot.forEach(childSnap => {
                            updates[`${childSnap.key}/ciclo`] = 1; 
                        });
                        if (Object.keys(updates).length > 0) {
                            console.log(`Migrando ${Object.keys(updates).length} entradas do histórico de 'ciclo_1' para ciclo: 1...`);
                            await historicoRef.update(updates);
                            console.log("Migração do campo 'ciclo' em historicoMapas concluída.");
                        }
                    }
                }
            } else {
                console.log(`cicloAtualId '${activeCycleId}' não aponta para um ciclo existente. Removendo.`);
                await db.ref("cicloAtualId").remove();
                activeCycleData = null;
            }
        } else {
             console.log("Nenhum cicloAtualId definido. Verificando se é necessário criar ciclo padrão...");
            const todosCiclosSnap = await db.ref('ciclos').once('value');
            if (!todosCiclosSnap.exists()) { 
                const historicoSnap = await db.ref('historicoMapas').limitToFirst(1).once('value');
                if (historicoSnap.exists()) {
                    console.log("Dados históricos encontrados e nenhum ciclo em /ciclos. Criando 'Ciclo Inicial Padrão'.");
                    const nomePrimeiroCiclo = "Ciclo Inicial Padrão"; 
                    const numeroPrimeiroCiclo = 1;
                    const dataInicioPrimeiroCiclo = "2023-01-01"; 

                    const novoCicloRef = db.ref('ciclos').push(); 
                    const primeiroCicloData = {
                        nome: nomePrimeiroCiclo,
                        numero: numeroPrimeiroCiclo,
                        status: 'ativo', 
                        dataInicio: dataInicioPrimeiroCiclo,
                        dataFim: null 
                    };
                    await novoCicloRef.set(primeiroCicloData);
                    await db.ref('cicloAtualId').set(novoCicloRef.key); 
                    activeCycleData = { id: novoCicloRef.key, ...primeiroCicloData }; 
                    console.log(`'${nomePrimeiroCiclo}' (Nº ${numeroPrimeiroCiclo}) criado com ID ${novoCicloRef.key} e definido como ativo.`);
                } else {
                    console.log("Nenhum ciclo em /ciclos e nenhum dado histórico. Sistema aguardando criação do primeiro ciclo.");
                    activeCycleData = null;
                }
            } else {
                console.log("/ciclos existe, mas nenhum ciclo ativo está definido via cicloAtualId.");
                activeCycleData = null; 
            }
        }
        
        const allCyclesSnap = await db.ref('ciclos').once('value');
        allCyclesMap = {};
        if(allCyclesSnap.exists()){
            allCyclesSnap.forEach(snap => {
                allCyclesMap[snap.key] = snap.val(); 
                if(snap.val().numero) allCyclesMap[snap.val().numero] = snap.val(); 
            });
        }

        updateCycleUI();
        carregarDados(); 
    }

    function updateCycleUI() {
        const display = document.getElementById('current-cycle-display');
        const pauseBtn = document.getElementById('pause-cycle-btn');
        const continueBtn = document.getElementById('continue-cycle-btn');
        
        if (activeCycleData) {
            display.innerHTML = `Nº ${activeCycleData.numero}: ${activeCycleData.nome} <br>(Status: ${activeCycleData.status})`;
            pauseBtn.style.display = activeCycleData.status === 'ativo' ? 'inline-block' : 'none';
        } else {
            display.textContent = "Nenhum ciclo ativo";
            pauseBtn.style.display = 'none';
        }
        
        db.ref('ciclos').orderByChild('status').equalTo('pausado').once('value', snap => {
            continueBtn.style.display = snap.exists() ? 'inline-block' : 'none';
        });
        atualizarBarraProgresso();
    }
    
    async function startNewCyclePrompt() {
        const nomeNovoCiclo = prompt("Digite o nome para o novo ciclo:");
        if (!nomeNovoCiclo || nomeNovoCiclo.trim() === "") {
            alert("Nome do ciclo não pode ser vazio.");
            return;
        }

        try {
            if (activeCycleData && activeCycleData.id && activeCycleData.status === 'ativo') {
                console.log(`Marcando ciclo atual '${activeCycleData.nome}' como concluído.`);
                await db.ref(`ciclos/${activeCycleData.id}`).update({ 
                    status: 'concluido',
                    dataFim: getTodayDateString()
                });
            }

            const allCiclosSnap = await db.ref('ciclos').once('value');
            let novoNumeroCiclo = 1; 
            if (allCiclosSnap.exists()) {
                let maxNumero = 0;
                allCiclosSnap.forEach(childSnap => {
                    const cycle = childSnap.val();
                    if (cycle && typeof cycle.numero !== 'undefined' && cycle.numero > maxNumero) {
                        maxNumero = cycle.numero;
                    }
                });
                novoNumeroCiclo = maxNumero + 1;
            }
            console.log(`Novo número do ciclo será: ${novoNumeroCiclo}`);
            
            const novoCicloRef = db.ref('ciclos').push();
            const novoCiclo = {
                nome: nomeNovoCiclo.trim(),
                numero: novoNumeroCiclo,
                status: 'ativo',
                dataInicio: getTodayDateString(),
                dataFim: null
            };
            await novoCicloRef.set(novoCiclo);
            await db.ref('cicloAtualId').set(novoCicloRef.key);
            
            alert(`Novo ciclo "${novoCiclo.nome}" (Nº ${novoCiclo.numero}) iniciado!`);
            await loadActiveCycleDetails();
        } catch (error) {
            console.error("Erro ao iniciar novo ciclo: ", error);
            alert("Falha ao iniciar novo ciclo. Verifique o console para detalhes.");
        }
    }

    async function pauseActiveCycle() {
        if (!activeCycleData || activeCycleData.status !== 'ativo') {
            alert("Nenhum ciclo ativo para pausar.");
            return;
        }
        if (!confirm(`Tem certeza que deseja pausar o ciclo "${activeCycleData.nome}" (Nº ${activeCycleData.numero})?`)) return;

        try {
            await db.ref(`ciclos/${activeCycleData.id}`).update({ status: 'pausado' });
            alert(`Ciclo "${activeCycleData.nome}" pausado.`);
            activeCycleData.status = 'pausado'; 
            updateCycleUI();
            carregarDados(); 
        } catch (error) {
            console.error("Erro ao pausar ciclo: ", error);
            alert("Falha ao pausar ciclo.");
        }
    }

    async function populateCycleSelector(purpose, filterStatus = null) {
        const selectionArea = document.getElementById('cycle-selection-area');
        selectionArea.innerHTML = ''; 

        const ciclosSnap = await db.ref('ciclos').once('value');
        if (!ciclosSnap.exists()) {
            selectionArea.innerHTML = '<p>Nenhum ciclo encontrado.</p>';
            return null;
        }

        const select = document.createElement('select');
        select.id = `cycle-selector-${purpose}`;
        let hasOptions = false;
        const cyclesArray = [];
        ciclosSnap.forEach(childSnap => {
            cyclesArray.push({ id: childSnap.key, ...childSnap.val() });
        });

        cyclesArray.sort((a,b) => (a.numero || 0) - (b.numero || 0));

        cyclesArray.forEach(cycle => {
            if (filterStatus && cycle.status !== filterStatus) {
                return;
            }
            const option = document.createElement('option');
            option.value = cycle.id;
            option.textContent = `Nº ${cycle.numero}: ${cycle.nome} (Status: ${cycle.status})`;
            select.appendChild(option);
            hasOptions = true;
        });

        if (!hasOptions) {
             selectionArea.innerHTML = `<p>Nenhum ciclo ${filterStatus ? '"'+filterStatus+'"' : ''} encontrado para ${purpose === 'continue' ? 'continuar' : 'excluir'}.</p>`;
            return null;
        }
        
        const label = document.createElement('label');
        label.htmlFor = select.id;
        label.textContent = `Selecione o ciclo para ${purpose === 'continue' ? 'continuar' : 'excluir'}: `;
        selectionArea.appendChild(label);
        selectionArea.appendChild(select);
        return select;
    }
    
    async function continueCyclePrompt() {
        const selector = await populateCycleSelector('continue', 'pausado');
        if (!selector) return;

        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Continuar Ciclo Selecionado';
        confirmBtn.onclick = async () => {
            const selectedCycleId = selector.value;
            if (!selectedCycleId) return;
            
            if(activeCycleData && activeCycleData.id !== selectedCycleId && activeCycleData.status === 'ativo') {
                 await db.ref(`ciclos/${activeCycleData.id}`).update({ status: 'pausado' });
            }

            await db.ref(`ciclos/${selectedCycleId}`).update({ status: 'ativo' });
            await db.ref('cicloAtualId').set(selectedCycleId);
            alert('Ciclo continuado!');
            document.getElementById('cycle-selection-area').innerHTML = ''; 
            await loadActiveCycleDetails();
        };
        document.getElementById('cycle-selection-area').appendChild(confirmBtn);
    }
    
    async function excludeCyclePrompt() {
        const selector = await populateCycleSelector('exclude');
        if (!selector) return;

        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Excluir Ciclo Selecionado';
        confirmBtn.classList.add('danger-action');
        confirmBtn.onclick = async () => {
            const selectedCycleId = selector.value;
            if (!selectedCycleId) return;
            const selectedOptionText = selector.options[selector.selectedIndex].text;

            if (!confirm(`TEM CERTEZA que deseja excluir o ciclo "${selectedOptionText}"? Mapas históricos associados a este ciclo NÃO serão excluídos, mas o ciclo sim.`)) return;

            try {
                await db.ref(`ciclos/${selectedCycleId}`).remove();
                if (activeCycleData && activeCycleData.id === selectedCycleId) {
                    await db.ref('cicloAtualId').remove();
                }
                alert(`Ciclo "${selectedOptionText}" excluído.`);
                document.getElementById('cycle-selection-area').innerHTML = ''; 
                await loadActiveCycleDetails(); 
            } catch (error) {
                console.error("Erro ao excluir ciclo: ", error);
                alert("Falha ao excluir ciclo.");
            }
        };
        document.getElementById('cycle-selection-area').appendChild(confirmBtn);
    }
// Cole esta função completa no lugar da função atualizarBarraProgresso existente em relatorio.html

function atualizarBarraProgresso() {
    const bar = document.getElementById("progress-bar");
    if (!activeCycleData || typeof activeCycleData.numero === 'undefined') {
        bar.style.width = "0%";
        bar.textContent = "Nenhum ciclo ativo";
        return;
    }

    const cicloAtualNumero = activeCycleData.numero;
    // Presumindo que totalMapasGlobal de firebase.js (38) é o total para um ciclo.
    // Se este valor puder mudar, você pode querer torná-lo dinâmico.
    const totalMapasNoCiclo = 38; 

    // Promise para buscar mapas concluídos do historicoMapas principal
    const promiseHistorico = db.ref("historicoMapas")
        .orderByChild("ciclo")
        .equalTo(cicloAtualNumero) // Busca apenas do ciclo ativo
        .once("value");

    // Promise para buscar mapas concluídos do historico_arquivado
    // Atenção: Isso busca todo o nó 'historico_arquivado'.
    // Se este nó se tornar muito grande, essa abordagem pode ficar lenta,
    // pois o filtro por ciclo será feito no lado do cliente.
    const promiseArquivado = db.ref("historico_arquivado")
        .once("value");

    Promise.all([promiseHistorico, promiseArquivado]).then(snapshots => {
        const historicoSnap = snapshots[0];
        const arquivadoSnap = snapshots[1];

        let completedMapIds = new Set(); // Usaremos um Set para contar IDs de mapas únicos

        // Processar historicoMapas principal
        if (historicoSnap.exists()) {
            historicoSnap.forEach(childSnap => {
                const registro = childSnap.val();
                // Considera apenas se tem dataFim e pertence ao ciclo atual (já filtrado pela query)
                if (registro && registro.dataFim && String(registro.dataFim).trim() !== "" && registro.mapa) {
                    completedMapIds.add(String(registro.mapa));
                }
            });
        }

        // Processar historico_arquivado
        if (arquivadoSnap.exists()) {
            arquivadoSnap.forEach(childSnap => {
                const registroArchived = childSnap.val();
                // Filtra para garantir que o registro arquivado pertence ao ciclo ativo e tem dataFim
                if (registroArchived && 
                    String(registroArchived.ciclo) === String(cicloAtualNumero) && 
                    registroArchived.dataFim && String(registroArchived.dataFim).trim() !== "" &&
                    registroArchived.mapa) {
                    completedMapIds.add(String(registroArchived.mapa));
                }
            });
        }

        const mapasCompletosUnicos = completedMapIds.size;
        const percent = totalMapasNoCiclo > 0 ? Math.round((mapasCompletosUnicos / totalMapasNoCiclo) * 100) : 0;
        
        const cycleName = activeCycleData.nome || `Ciclo ${activeCycleData.numero}`;
        bar.style.width = percent + "%";
        bar.textContent = `${cycleName} — ${percent}% (${mapasCompletosUnicos}/${totalMapasNoCiclo})`;

    }).catch(error => {
        console.error("Erro ao atualizar barra de progresso:", error);
        bar.style.width = "0%";
        bar.textContent = "Erro ao carregar progresso";
    });
}

    async function salvarNoHistorico(id, nome, inicio, fim) {
      if (!activeCycleData || activeCycleData.status !== 'ativo' || typeof activeCycleData.numero === 'undefined') {
          alert("Não há um ciclo ativo para salvar o mapa. Inicie ou continue um ciclo.");
          return;
      }
      const cicloNumeroParaSalvar = activeCycleData.numero;

      const ref = db.ref("historicoMapas");
      const snap = await ref.orderByChild("mapa").equalTo(id).once("value");
      const registros = snap.val() || {};

      for (const key in registros) {
        const registro = registros[key];
        if (registro.ciclo === cicloNumeroParaSalvar && registro.mapa === id) { 
          await db.ref("historicoMapas/" + key).remove();
        }
      }

      await ref.push({
        mapa: id,
        nome: nome || "", 
        dataInicio: inicio,
        dataFim: fim,
        ciclo: cicloNumeroParaSalvar 
      });

      await db.ref(`mapas/${id}`).remove(); 
      carregarDados(); 
    }
    
    function toggleGlobalHistoricoEdit() {
        const button = document.getElementById('toggle-historico-edit-btn');
        if (isHistoricoEditingGlobal) { 
            saveAllHistoricoChanges();
        } else { 
            isHistoricoEditingGlobal = true;
            button.textContent = 'Salvar Alterações e Desabilitar';
            button.classList.add('warning-action');
            carregarDados(); 
        }
    }

    async function saveAllHistoricoChanges() {
        const promises = [];
        const rows = document.querySelectorAll("#historico-body tr");
        rows.forEach(row => {
            const key = row.getAttribute('data-key');
            if (!key) return;

            const newNameInput = row.cells[1].querySelector('input.nome-input');
            const newDataInicioInput = row.cells[2].querySelector('input.dataInicio-input');
            const newDataFimInput = row.cells[3].querySelector('input.dataFim-input');

            if (!newNameInput || !newDataInicioInput || !newDataFimInput) {
                console.warn(`Inputs não encontrados para edição na linha com chave ${key}. Pulando.`);
                return;
            }

            const updatedData = {
                nome: newNameInput.value,
                dataInicio: newDataInicioInput.value,
                dataFim: newDataFimInput.value
                // Não atualizamos 'ciclo' aqui, pois é estrutural
            };
            promises.push(db.ref("historicoMapas/" + key).update(updatedData));
        });

        try {
            await Promise.all(promises);
            alert('Todas as alterações foram salvas!');
        } catch (error) {
            console.error("Erro ao salvar alterações globais: ", error);
            alert('Falha ao salvar algumas alterações.');
        }
        
        isHistoricoEditingGlobal = false;
        const button = document.getElementById('toggle-historico-edit-btn');
        button.textContent = 'Habilitar Edição Geral';
        button.classList.remove('warning-action');
        carregarDados(); 
    }

    // NOVA FUNÇÃO PARA ARQUIVAR E REABRIR
    async function archiveAndReopenMap(histKey, historyEntryDataString) {
        // Parse a string JSON de volta para um objeto
        const historyEntryData = JSON.parse(decodeURIComponent(historyEntryDataString));

        if (!activeCycleData || typeof activeCycleData.numero === 'undefined') {
            alert("Não há um ciclo ativo definido. Ação cancelada.");
            return;
        }

        // Confirma que a ação é para o ciclo ativo.
        // historyEntryData.ciclo pode ser número ou string, activeCycleData.numero é número.
        if (String(historyEntryData.ciclo) !== String(activeCycleData.numero)) {
            alert("Esta ação só pode ser realizada em registros do ciclo ativo atual.");
            return;
        }

        const mapId = historyEntryData.mapa;
        const confirmMsg = `Tem certeza que deseja arquivar este registro do Mapa ${mapId} (Ciclo ${historyEntryData.ciclo}) e reabri-lo para um novo trabalho? ` +
                         `O registro atual será movido para um arquivo separado ('historico_arquivado') e os campos no formulário principal (index.html) serão limpos para este mapa.`;

        if (confirm(confirmMsg)) {
            try {
                // 1. Copiar para o nó 'historico_arquivado'
                // Usaremos o mesmo histKey para simplicidade, ou crie um novo se preferir.
                await db.ref(`historico_arquivado/${histKey}`).set(historyEntryData);

                // 2. Limpar/Remover os dados de 'mapas em andamento' para este mapa,
                // para garantir que o index.html o carregue como "novo" (campos limpos).
                await db.ref(`mapas/${mapId}`).remove();

                // 3. Remover o registro original do 'historicoMapas'
                await db.ref(`historicoMapas/${histKey}`).remove();

                alert(`Mapa ${mapId} (Ciclo ${historyEntryData.ciclo}) foi arquivado com sucesso. Os campos para este mapa no formulário principal (index.html) estão prontos para novo registro.`);
                
                carregarDados(); // Recarrega os dados em relatorio.html (inclusive barra de progresso)
            } catch (error) {
                console.error("Erro ao arquivar e reabrir mapa:", error);
                alert("Erro ao arquivar e reabrir mapa: " + error.message);
            }
        }
    }


    function carregarDados() {
      console.log("Carregando dados dos mapas...");
      // Carregar Mapas em Andamento
      db.ref("mapas").once("value").then(snap => {
        const tbody = document.getElementById("relatorio-body");
        tbody.innerHTML = "";
        const mapasData = snap.val();
        if (mapasData) {
            Object.entries(mapasData).forEach(([id, dados]) => {
              if (!dados || typeof dados !== 'object') {
                  return; 
              }

              const mapId = id; 
              
              const nomePreenchido = dados.nome && String(dados.nome).trim() !== "";
              const dataInicioPreenchida = dados.dataInicio && String(dados.dataInicio).trim() !== "";
              const dataFimPreenchida = dados.dataFim && String(dados.dataFim).trim() !== "";

              if (nomePreenchido || dataInicioPreenchida || dataFimPreenchida) {
                const tr = document.createElement("tr");
                const nomeInputId = `nome-input-${mapId}`;
                const saveButtonDisabled = (!activeCycleData || activeCycleData.status !== 'ativo');
                
                const botao = `<button ${saveButtonDisabled ? 'disabled title="Inicie ou continue um ciclo para salvar."' : ''} onclick="salvarNoHistorico('${mapId}', document.getElementById('${nomeInputId}').value, '${dados.dataInicio || ''}', '${dados.dataFim || ''}')">Salvar</button>`;
                  
                tr.innerHTML = `
                  <td>${mapId}</td>
                  <td><input type="text" id="${nomeInputId}" class="edit-input" value="${dados.nome || ''}" placeholder="Designado para"></td>
                  <td>${formatarData(dados.dataInicio || '')}</td> 
                  <td>${formatarData(dados.dataFim || '')}</td>   
                  <td>${botao}</td>
                `;
                tbody.appendChild(tr);
              }
            });
        }
        atualizarBarraProgresso(); 
      }).catch(error => console.error("Erro ao carregar mapas em andamento:", error));

      // Carregar Histórico de Mapas Concluídos
      db.ref("historicoMapas").once("value").then(snap => {
        const tbodyHistorico = document.getElementById("historico-body");
        tbodyHistorico.innerHTML = "";
        const historico = snap.val() || {};
        
        Object.entries(historico)
          .sort(([,a], [,b]) => { 
            const cicloA = typeof a.ciclo === 'string' && a.ciclo === 'ciclo_1' ? 1 : (a.ciclo || 0);
            const cicloB = typeof b.ciclo === 'string' && b.ciclo === 'ciclo_1' ? 1 : (b.ciclo || 0);
            if (cicloA !== cicloB) return cicloA - cicloB;
            return Number(a.mapa) - Number(b.mapa);
          })
          .forEach(([key, reg]) => {
            if (typeof reg.mapa === 'undefined' || (typeof reg.ciclo === 'undefined' && reg.ciclo !== null) ) {
                return; 
            }

            const tr = document.createElement("tr");
            tr.setAttribute('data-key', key);
            
            let cicloDisplay = 'N/A';
            const cicloValor = reg.ciclo; 

            if (cicloValor === 'ciclo_1' && allCyclesMap[1]) { 
                const cicloInfo = allCyclesMap[1];
                cicloDisplay = `Nº ${cicloInfo.numero}: ${cicloInfo.nome}`;
            } else if (typeof cicloValor === 'number' && allCyclesMap[cicloValor]) {
                const cicloInfo = allCyclesMap[cicloValor]; 
                cicloDisplay = `Nº ${cicloInfo.numero}: ${cicloInfo.nome}`;
            } else if (typeof cicloValor === 'number') { 
                cicloDisplay = `Nº ${cicloValor}`;
            } else if (cicloValor === 'ciclo_1') { 
                cicloDisplay = `Nº 1`;
            } else if (cicloValor) { 
                if(allCyclesMap[cicloValor] && typeof allCyclesMap[cicloValor] === 'object' && allCyclesMap[cicloValor].numero !== undefined){ 
                     const cicloInfo = allCyclesMap[cicloValor];
                     cicloDisplay = `Nº ${cicloInfo.numero}: ${cicloInfo.nome}`;
                } else {
                    cicloDisplay = String(cicloValor); 
                }
            }
            
            let actionCellContent = '';
            // Condições para mostrar o botão "Arquivar e Reabrir":
            // 1. activeCycleData deve existir e ter um número.
            // 2. O ciclo do registro (reg.ciclo) deve ser igual ao ciclo ativo.
            // 3. O registro deve ter uma data de fim (reg.dataFim).
            // 4. Não estar no modo de edição global (isHistoricoEditingGlobal === false).
            if (activeCycleData && typeof activeCycleData.numero !== 'undefined' && 
                String(reg.ciclo) === String(activeCycleData.numero) && 
                reg.dataFim && String(reg.dataFim).trim() !== "" && 
                !isHistoricoEditingGlobal) {
                
                // Prepara o objeto de dados para ser passado para a função.
                // Usamos encodeURIComponent para garantir que a string JSON seja segura para o atributo HTML.
                const regJsonString = encodeURIComponent(JSON.stringify(reg));
                actionCellContent = `<button onclick='archiveAndReopenMap("${key}", "${regJsonString}")' class='secondary-action archive-btn' title='Arquiva este registro e libera o mapa para novo trabalho no formulário principal.'>Arquivar e Reabrir</button>`;
            }


            if (isHistoricoEditingGlobal) {
                tr.innerHTML = `
                  <td>${reg.mapa}</td>
                  <td><input type="text" class="edit-input nome-input" value="${reg.nome || ''}"></td>
                  <td><input type="date" class="edit-input dataInicio-input" value="${reg.dataInicio || ''}"></td>
                  <td><input type="date" class="edit-input dataFim-input" value="${reg.dataFim || ''}"></td>
                  <td>${cicloDisplay}</td>
                  <td>${actionCellContent}</td> 
                `;
            } else {
                tr.innerHTML = `
                  <td>${reg.mapa}</td>
                  <td>${reg.nome || '—'}</td>
                  <td>${formatarData(reg.dataInicio)}</td>
                  <td>${formatarData(reg.dataFim)}</td>
                  <td>${cicloDisplay}</td>
                  <td>${actionCellContent}</td> 
                `;
            }
            tbodyHistorico.appendChild(tr);
          });
      }).catch(error => console.error("Erro ao carregar histórico de mapas:", error));
    }

    document.addEventListener("DOMContentLoaded", async () => {
      console.log("DOM Carregado. Iniciando sistema de ciclos...");
      await loadActiveCycleDetails(); 
    });
  </script>
</body>
</html>